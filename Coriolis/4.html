<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>3D-Animation: Gradnetz &amp; Teilchenbahn (Canvas-3D)</title>

  <!-- Stil wie beigefügt -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Raleway:wght@300;400;500&display=swap" rel="stylesheet"/>
  <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet"/>

  <style>
    html, body { margin:0; padding:0; width:100%; min-height:100%; background:#F5F5F5; color:#333; font-family:'Montserrat',sans-serif; }
    .slide-container { width:100%; min-height:720px; display:flex; flex-direction:column; }

    .slide-header { background:#2A3B32; color:#fff; padding:1.25rem 2rem; display:flex; justify-content:space-between; align-items:center; }
    .title { margin:0; font-weight:700; font-size:2.1rem; }
    .divider { width:110px; height:4px; background:#E6B400; border-radius:3px; margin-top:.6rem; }

    .slide-content { flex:1 1 auto; padding:1.25rem 2rem 1.5rem 2rem; display:flex; flex-direction:column; gap:1rem; }

    .material { background:#fff; border:1px solid #E5E7EB; border-radius:12px; box-shadow:0 2px 8px rgba(0,0,0,.05);
      overflow:hidden; display:flex; flex-direction:column; transition: transform .18s ease, box-shadow .18s ease; }
    .material:hover{ transform: translateY(-3px); box-shadow:0 14px 28px rgba(0,0,0,.10); }

    .mat-head { display:flex; align-items:center; gap:.6rem; padding:.7rem .9rem; background:#F9FAFB; border-bottom:1px solid #E5E7EB; }
    .badge { background:#2A3B32; color:#fff; font-weight:700; font-size:.9rem; padding:.15rem .55rem; border-radius:6px; min-width:3.0rem; text-align:center; }
    .mat-title { font-weight:600; color:#2A3B32; font-size:1.05rem; }
    .mat-body { padding:.9rem; font-family:'Raleway',sans-serif; }

    .tiny { font-size:.9rem; color:#4B5563; }

    .viewer-wrap{ position:relative; width:100%; height:min(72vh, 720px); min-height:520px; background:#ffffff;
      border:1px solid #E5E7EB; border-radius:12px; overflow:hidden; }
    canvas{ display:block; width:100%; height:100%; background:#fff; touch-action:none; }

    .hud{ position:absolute; top:12px; left:12px; display:flex; flex-direction:column; gap:.55rem; z-index:5; pointer-events:none; }
    .chip{ pointer-events:none; background:rgba(42,59,50,.08); border:1px solid rgba(42,59,50,.20); padding:.45rem .6rem;
      border-radius:10px; color:#1f2937; font-family:'Raleway',sans-serif; font-size:.86rem; backdrop-filter: blur(4px); }

    .controls{ display:flex; gap:.75rem; flex-wrap:wrap; align-items:center; margin-top:.75rem; padding:.75rem;
      background:#E9F0EC; border:2px solid #2A3B32; border-radius:12px; font-family:'Raleway',sans-serif; }
    .controls .lbl{ font-weight:700; color:#2A3B32; margin-right:.25rem; }
    .btn{ background:#2A3B32; color:#fff; border:1px solid rgba(0,0,0,.10); border-radius:10px; padding:.45rem .7rem; font-weight:700;
      transition: transform .18s ease, box-shadow .18s ease; }
    .btn:hover{ transform: translateY(-2px); box-shadow:0 10px 18px rgba(0,0,0,.10); }
    .range{ accent-color:#2A3B32; }

    .footer { padding:0 2rem 1rem 2rem; display:flex; justify-content:space-between; color:#666; font-size:.9rem; font-family:'Raleway',sans-serif; }
  </style>
</head>

<body>
  <div class="slide-container">
    <div class="slide-header">
      <div>
        <h1 class="title">Abhängigkeiten der Corioliskraft</h1>
        <div class="divider"></div>
      </div>
      <p class="text-sm font-light">Geographie | Klasse 10</p>
    </div>

    <div class="slide-content">
      <div class="material">
        <div class="mat-head">
          <span class="badge">M1</span>
          <a href="5.html"><div class="mat-title"><i>Simulation:</i> Abhängigkeit der "horizontalen" Geschwindigkeit von der geographischen Breite</div></a>
        </div>

        <div class="mat-body">
          <div class="viewer-wrap" id="viewer">
            <div class="hud">
            <div class="chip"><p class="tiny">
            <strong>Bedienung:</strong> <br>Linksklick ziehen = Kugel drehen<br>Mausrad/Pinch = Zoom.<br>
            Die Erde (Gradnetz) rotiert gleichmäßig um ihre Achse.<br>
            Die <span style="color:#dc2626; font-weight:700;">rote Kugel</span> bewegt sich mit konstanter Geschwindigkeit<br>
            zwischen zwei <strong>festen</strong> Punkten am Äquator <br>(sie rotiert <strong>nicht</strong> mit der Erde) über den Nordpol.
           </p>
           </div>
            </div>
            <canvas id="c"></canvas>
          </div>

          
        </div>
      </div>

<div class="controls">
            <span class="lbl"><i class="fas fa-sync-alt mr-2"></i>Rotation</span>
            <button class="btn" id="toggleEarth"><i class="fas fa-pause mr-2"></i>Pause</button>

            <span class="lbl" style="margin-left:.25rem;"><i class="fas fa-tachometer-alt mr-2"></i>Geschwindigkeit</span>
            <input class="range" id="speed" type="range" min="0.25" max="2.5" step="0.05" value="1.0"/>
            <span id="speedLabel" class="tiny" style="margin-left:-.25rem;">1.00×</span>

            <button class="btn" id="resetView" style="margin-left:auto;"><i class="fas fa-crosshairs mr-2"></i>Ansicht zurücksetzen</button>
          </div>

    </div>



    <div class="footer">
      <p>Theo Schierbaum – Corioliskraft</p>
      <p>Seite 4</p>
    </div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('c');
  const wrap = document.getElementById('viewer');

  const speedSlider = document.getElementById('speed');
  const speedLabel  = document.getElementById('speedLabel');
  const toggleBtn   = document.getElementById('toggleEarth');
  const resetBtn    = document.getElementById('resetView');

  if(!canvas || !wrap) return;

  const ctx = canvas.getContext('2d', { alpha:false });

  // ---------- Math helpers ----------
  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

  function rotX(v, a){
    const c=Math.cos(a), s=Math.sin(a);
    return { x:v.x, y:v.y*c - v.z*s, z:v.y*s + v.z*c };
  }
  function rotY(v, a){
    const c=Math.cos(a), s=Math.sin(a);
    return { x:v.x*c + v.z*s, y:v.y, z:-v.x*s + v.z*c };
  }

  // Compose view rotation: yaw then pitch
  function applyView(v){
    let o = rotY(v, viewYaw);
    o = rotX(o, viewPitch);
    return o;
  }
  // Earth rotation then view
  function applyEarth(v){
    let o = rotY(v, earthSpin);
    return applyView(o);
  }

  // ---------- Orthographic projection ----------
  // (Damit ist in der Polansicht der Äquator garantiert der größte Kreis.)
  let zoom = 1.0;
  function projectOrtho(v, w, h){
    const s = 0.42 * Math.min(w, h) * zoom;
    return { x: w*0.5 + v.x*s, y: h*0.5 - v.y*s, z: v.z };
  }

  // ---------- Geometry (unit sphere) ----------
  const R = 1.0;

  function latCircle(latDeg, seg=240){
    const lat = latDeg * Math.PI/180;
    const y = Math.sin(lat) * R;
    const r = Math.cos(lat) * R;
    const pts=[];
    for(let i=0;i<=seg;i++){
      const a = (i/seg) * Math.PI*2;
      pts.push({ x: Math.cos(a)*r, y:y, z: Math.sin(a)*r });
    }
    return pts;
  }

  function lonGreatCircle(lonDeg, seg=240){
    // vollständiger Großkreis (Meridian) in einer Ebene durch Rotationsachse
    const lon = lonDeg * Math.PI/180;
    const pts=[];
    for(let i=0;i<=seg;i++){
      const a = (i/seg) * Math.PI*2; // 0..2π (geschlossener Kreis)
      const y = Math.sin(a) * R;
      const r = Math.cos(a) * R;
      pts.push({ x: Math.cos(lon)*r, y:y, z: Math.sin(lon)*r });
    }
    return pts;
  }

  const linesEarth = [];
  for(let lat=-75; lat<=75; lat+=15) linesEarth.push(latCircle(lat));
  // Ein Meridian ist ein Großkreis: lon und lon+180 sind derselbe Kreis → 0..180 reicht (ergibt in der Polansicht Durchmesser in allen Richtungen)
  for(let lon=0; lon<180; lon+=15)   linesEarth.push(lonGreatCircle(lon));
  const equator = latCircle(0);

  // Fixed path in world (X–Y plane): arc from (1,0,0) to (-1,0,0) via North Pole
  const arcPts=[];
  const arcSeg=220;
  for(let i=0;i<=arcSeg;i++){
    const a = (i/arcSeg) * Math.PI;
    arcPts.push({ x: Math.cos(a)*R, y: Math.sin(a)*R, z: 0 });
  }

  const A = { x:  1, y:0, z:0 };
  const B = { x: -1, y:0, z:0 };

  // ---------- State ----------
  let earthRunning = true;
  let earthOmega   = 0.55; // rad/s
  let travelOmega  = 0.85; // rad/s

  let viewYaw = 0.35;
  let viewPitch = -0.25;
  let earthSpin = 0;

  // ---------- Canvas sizing ----------
  function resize(){
    const r = wrap.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width  = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    canvas.style.width = r.width + "px";
    canvas.style.height= r.height + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  function resetView(){
    viewYaw = 0.35;
    viewPitch = -0.25;
    zoom = 1.0;
  }

  // ---------- Pointer controls ----------
  let dragging=false, lastX=0, lastY=0, activePointerId=null;

  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    dragging=true;
    activePointerId = e.pointerId;
    lastX=e.clientX; lastY=e.clientY;
  });

  canvas.addEventListener('pointerup', ()=>{ dragging=false; activePointerId=null; });
  canvas.addEventListener('pointercancel', ()=>{ dragging=false; activePointerId=null; });

  canvas.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    if(activePointerId !== null && e.pointerId !== activePointerId) return;

    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    lastX=e.clientX; lastY=e.clientY;

    viewYaw   += dx * 0.006;
    viewPitch += dy * 0.006;
    viewPitch = clamp(viewPitch, -(Math.PI/2 - 0.01), (Math.PI/2 - 0.01));
  });

  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    zoom *= (delta>0) ? 0.92 : 1.08;
    zoom = clamp(zoom, 0.55, 2.4);
  }, { passive:false });

  // ---------- UI ----------
  speedSlider.addEventListener('input', ()=>{ speedLabel.textContent = Number(speedSlider.value).toFixed(2) + "×"; });

  toggleBtn.addEventListener('click', ()=>{
    earthRunning = !earthRunning;
    toggleBtn.innerHTML = earthRunning
      ? '<i class="fas fa-pause mr-2"></i>Pause'
      : '<i class="fas fa-play mr-2"></i>Weiter';
  });

  resetBtn.addEventListener('click', resetView);

  // ---------- Drawing helpers ----------
  function strokePolyline(points, xform, w, h, color, baseWidth, alphaNear, alphaFar){
    for(let i=0;i<points.length-1;i++){
      const p0 = xform(points[i]);
      const p1 = xform(points[i+1]);

      const q0 = projectOrtho(p0, w, h);
      const q1 = projectOrtho(p1, w, h);

      const zAvg = (p0.z + p1.z) * 0.5;
      const t = clamp((zAvg + 1.0) / 2.0, 0, 1); // 0 far, 1 near
      const a = alphaFar + (alphaNear - alphaFar) * t;

      ctx.strokeStyle = color;
      ctx.globalAlpha = a;
      ctx.lineWidth = baseWidth;

      ctx.beginPath();
      ctx.moveTo(q0.x, q0.y);
      ctx.lineTo(q1.x, q1.y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function strokePolylineConst(points, xform, w, h, color, width, alpha){
    ctx.strokeStyle = color;
    ctx.globalAlpha = alpha;
    ctx.lineWidth = width;
    ctx.beginPath();
    for(let i=0;i<points.length;i++){
      const p = xform(points[i]);
      const q = projectOrtho(p, w, h);
      if(i===0) ctx.moveTo(q.x, q.y);
      else ctx.lineTo(q.x, q.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawMarker(vWorld, xform, w, h, rPx, fillStyle, strokeStyle){
    const v = xform(vWorld);
    const q = projectOrtho(v, w, h);
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(q.x, q.y, rPx, 0, Math.PI*2);
    ctx.fillStyle = fillStyle;
    ctx.fill();
    if(strokeStyle){
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  // ---------- Animation loop ----------
  let last = performance.now();
  function frame(now){
    requestAnimationFrame(frame);

    const dt = Math.min((now - last)/1000, 0.05);
    last = now;
    const speed = Number(speedSlider.value);

    if(earthRunning) earthSpin += earthOmega * speed * dt;

    // particle ping-pong
    const T = (Math.PI) / (travelOmega * speed);
    const cycle = (now/1000) / T;
    const u = cycle % 2;
    const a = (u < 1) ? (u * Math.PI) : ((2 - u) * Math.PI);
    const particle = { x: Math.cos(a)*R, y: Math.sin(a)*R, z: 0 };

    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,w,h);

    ctx.lineCap = "round";

    // Earth grid two-pass: faint (all) + near-side emphasized
    strokePolylineConst(equator, applyEarth, w, h, "#000000", 1.6, 0.22);
    for(let i=0;i<linesEarth.length;i++){
      strokePolylineConst(linesEarth[i], applyEarth, w, h, "#000000", 1.0, 0.18);
    }

    strokePolyline(equator, applyEarth, w, h, "#000000", 2.2, 0.98, 0.34);
    for(let i=0;i<linesEarth.length;i++){
      strokePolyline(linesEarth[i], applyEarth, w, h, "#000000", 1.3, 0.92, 0.28);
    }

    // fixed arc
    strokePolyline(arcPts, applyView, w, h, "#111827", 1.8, 0.35, 0.15);

    // fixed endpoints + particle
    drawMarker(A, applyView, w, h, 4.2, "#111827", null);
    drawMarker(B, applyView, w, h, 4.2, "#111827", null);
    drawMarker(particle, applyView, w, h, 6.0, "#dc2626", "#ffffff");
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
