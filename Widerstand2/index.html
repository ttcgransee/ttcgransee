<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Widerstände in Reihen-und Parallelschaltungen</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&amp;family=Raleway:wght@300;400;500;600&amp;display=swap" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet"/>
<style>
    /* Base Reset & Fonts */
    *, *::before, *::after { box-sizing: border-box; }

    html, body { 
        margin:0; 
        padding:0; 
        width:100%; 
        min-height:100%;
        height:auto;
        overflow:auto; /* page scrolls; footer is at end */
        background:#F5F5F5; 
        color:#333; 
        font-family:'Montserrat',sans-serif; 
    }

    /* Responsive Slide Container */
    /* Responsive Slide Container */
    .slide-container { 
        width: 100vw; 
        max-width: none; 
        min-height: 100vh; /* at least full viewport height */
        height: auto;
        margin: 0; 
        display: flex; 
        flex-direction: column; 
        position: relative; 
        background: #F5F5F5;
        overflow: visible; /* footer is not fixed */
    }
    
    /* Header Style */
    .slide-header {
      background:#2A3B32; color:#fff;
      padding:1.25rem 3rem;
      display:flex; justify-content:space-between; align-items:center;
      flex-shrink:0; /* Prevents header from shrinking */
    }
    .header-title { margin:0; font-weight:700; font-size:clamp(1.5rem, 4vw, 2.1rem); letter-spacing: 0.02em; }
    .divider { width:80px; height:5px; background:#E6B400; border-radius:3px; margin-top:.6rem; }
    .header-sub { font-weight:300; font-size: 1rem; opacity: 0.9; }
    
    /* Main Content - Scrollable */
    .slide-content {
      flex: 1 0 auto; /* grows, but page scrolls normally */
      padding:1.5rem 3rem 1rem 3rem;
      display:flex;
      flex-direction:column;
      gap:1rem;
      font-family:'Raleway',sans-serif;
      overflow: visible; /* no internal scrolling */
    }

    /* Materials Grid - Responsive */
    .materials-grid { 
        display:grid; 
        grid-template-columns:repeat(2, 1fr); 
        gap:1.5rem; 
        flex-shrink: 0; /* Ensures it takes necessary space */
    }
    
    @media (max-width: 768px) {
        .slide-header, .slide-content, .footer { padding-left: 1.5rem; padding-right: 1.5rem; }
        .materials-grid { grid-template-columns: 1fr; }
    }

    .material { 
        background:#fff; 
        border:1px solid #E5E7EB; 
        border-radius:12px; 
        box-shadow:0 4px 6px rgba(0,0,0,.05); 
        overflow:hidden; 
        display:flex; 
        flex-direction:column; 
    }
    
    .mat-head { 
        display:flex; 
        align-items:center; 
        gap:.8rem; 
        padding:.6rem 1rem; 
        background:#F9FAFB; 
        border-bottom:1px solid #E5E7EB; 
    }
    
    .badge { 
        background:#2A3B32; 
        color:#fff; 
        font-weight:700; 
        font-size:.9rem; 
        padding:.2rem .6rem; 
        border-radius:6px; 
        min-width:2.5rem; 
        text-align:center; 
    }
    
    .mat-title { 
        font-weight:700; 
        color:#2A3B32; 
        font-size:1.1rem; 
        font-family: 'Montserrat', sans-serif;
    }
    
    .mat-body { 
        padding:1rem; 
        font-family:'Raleway',sans-serif; 
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        gap: 0.5rem;
    }

    /* Info Box inside Material */
    .info-box {
      background:#F3F4F6;
      border-radius:8px;
      padding:0.8rem;
      margin-bottom: 0.5rem;
      border-left: 4px solid #2A3B32;
    }
    .info-label {
      font-size:0.75rem;
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:0.05em;
      color:#4B5563;
      margin-bottom:0.3rem;
    }
    .main-text {
        font-size: 0.95rem;
        line-height: 1.5;
        color: #1F2937;
    }

    .example-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    .example-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
        font-size: 0.95rem;
    }
    .example-icon {
        width: 32px;
        height: 32px;
        background: #FEF3C7; /* yellow-100 */
        color: #D97706; /* yellow-600 */
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
    }

    /* Task Section */
    .task-section {
      position:relative;
      background:#E9F0EC;
      border:2px solid #2A3B32;
      border-radius:12px;
      padding:1rem 1.5rem;
      font-family:'Raleway',sans-serif;
      margin-top:0.5rem;
      margin-bottom: 0.5rem;
      flex-shrink: 0;
    }
    .task-label {
      position:absolute;
      top:-14px;
      left:1.5rem;
      background:#2A3B32;
      color:#fff;
      padding:.2rem .8rem;
      border-radius:6px;
      font-weight:600;
      font-size:.85rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .task-text {
        font-size: 1rem;
        color: #2A3B32;
        font-weight: 500;
    }

    /* Footer & Navigation */
    .footer {
      padding:1rem 3rem;
      display:grid;
      grid-template-columns: 1fr auto 1fr; /* Left text, Center buttons, Right text */
      align-items:center;
      color:#666; font-size:0.9rem;
      font-family:'Raleway',sans-serif;
      flex-shrink:0;
      background: #F5F5F5; /* Matches body bg */
      margin-top: auto; /* pushes footer to bottom if content is short */
      border-top: none; /* no footer separator line */
      }
    
    .footer-left { justify-self: start; }
    .footer-center { 
        display: flex; 
        gap: 1rem; 
        justify-self: center; 
    }
    .footer-right { justify-self: end; }

    .nav-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background-color: #2A3B32;
        color: white;
        padding: 0.5rem 1.25rem;
        border-radius: 8px;
        text-decoration: none;
        font-weight: 600;
        font-size: 0.9rem;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        min-width: 100px;
    }
    .nav-btn:hover {
        background-color: #3D5245;
        transform: translateY(-1px);
        box-shadow: 0 4px 6px rgba(0,0,0,0.15);
    }
    .nav-btn:active {
        transform: translateY(0);
    }
    
    /* Responsive Footer */
    @media (max-width: 640px) {
        .footer {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto;
            gap: 0.5rem;
            text-align: center;
            padding: 1rem;
        }
        .footer-left, .footer-center, .footer-right { justify-self: center; }
    }


    /* --- Drawing canvases (M1/M2) --- */
    .canvas-panel{
        position: relative;
        width: 100%;
        /* Height is driven by aspect-ratio (set via JS once images load) */
        height: auto;
        min-height: 260px;
        aspect-ratio: 4 / 3; /* fallback */
        background: #fff;
        border: 1px solid #E5E7EB;
        border-radius: 10px;
        overflow: hidden;
    }

    /* Media panel (M1) – no fixed aspect ratio, so images are never clipped */
    .media-panel{
        width: 100%;
        background: #fff;
        border: 1px solid #E5E7EB;
        border-radius: 10px;
        padding: 0.5rem;
        overflow: visible; /* let content define height */
    }
    .canvas-hint{
        position:absolute;
        top:10px;
        left:10px;
        z-index:3;
        background: rgba(0,0,0,0.55);
        color:#fff;
        font-size: 0.8rem;
        padding: 0.25rem 0.5rem;
        border-radius: 8px;
        pointer-events:none;
        user-select:none;
    }
    .canvas-bg-img{
        display:none; /* we draw it onto the canvas */
    }
    .draw-canvas{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        touch-action:none; /* prevents scrolling while drawing */
        cursor: crosshair;
        background:#fff;
    }


    /* Circuit canvas layering */
    #circuit-base { pointer-events: none; }
    #circuit-draw { background: transparent; }
</style>
</head>
<body>
<div class="slide-container">
<!-- Header -->
<div class="slide-header">
<div>
<h1 class="header-title">Widerstände in Reihen-und Parallelschaltungen</h1>
<div class="divider"></div>
</div>
<div class="text-right">
<p class="header-sub">Physik | Klasse 8</p>
</div>
</div>
<!-- Scrollable Content -->
<div class="slide-content">
<div class="materials-grid">
<!-- Left Column: Definition & Basics -->
<div class="column flex flex-col gap-4">
<section class="material h-full">
<div class="mat-head"><span class="badge">M1</span><div class="mat-title">Bsp. Elektrik in der Küche</div></div>
<div class="mat-body">
  <div class="media-panel">
    <!-- 3 Bilder: oben 1 Bild, unten 2 gleich große Bilder nebeneinander -->
    <div class="grid grid-rows-2 gap-2">
      <img alt="M1 Bild oben" src="KM.png" class="w-full h-auto object-contain"/>
      <div class="grid grid-cols-2 gap-2">
        <img alt="M1 Bild unten links" src="KM2.png" class="w-full h-auto object-contain"/>
        <img alt="M1 Bild unten rechts" src="KM3.png" class="w-full h-auto object-contain"/>
      </div>
    </div>
  </div>
</div>
</section>
</div>
<!-- Right Column: Effects & Examples -->
<div class="column flex flex-col gap-4">
<section class="material h-full">
<div class="mat-head"><span class="badge">M2</span><div class="mat-title">Berechnung des Stroms im Küchenstromkreis</div></div>
<div class="mat-body">
  <div class="canvas-panel" id="circuit-panel">
    <div class="canvas-hint">Zeichne mit Rot in den Schaltplan.</div>
    <canvas class="draw-canvas" id="circuit-base"></canvas>
    <canvas class="draw-canvas" id="circuit-draw"></canvas>
  </div>

  <div class="mt-3 flex flex-wrap gap-2 items-center">
    <button id="add-parallel" class="nav-btn" type="button">Parallelverbraucher hinzufügen</button>
    <button id="clear-drawing" class="nav-btn" type="button" style="background:#7A1F1F;">Rotmarkierungen löschen</button>
    <span id="parallel-status" class="text-sm text-gray-600"></span>
  </div>

  <p class="mt-3 main-text" id="circuit-explain">
    Der Schaltplan zeigt zunächst einen einfachen elektrischen Verbraucher <span style="color:#2563EB;font-weight:700;">R1 (Herd)</span>.
    An den beiden Anschlüssen ist die Spannung <span style="color:#8B5CF6;font-weight:700;">U</span> markiert, und in der Zuleitung ist der Strom
    <span style="color:#16A34A;font-weight:700;">I</span> eingezeichnet. Im Falle eines einzigen Verbrauchers kann der Strom mithilfe des Ohmschen Gesetzes (I=U/R) berechnet werden. Die Kenntnis über den zu erwartenden Strom ist wichtig für die Auslegung der Kabel (Querschnitt) und der Sicherung (8A oder 16A).
  </p>
</div>
</section>
</div>
</div>
<!-- Task / Merke Section -->
<section class="task-section">
<div class="task-label">Leitfrage</div>
<p class="task-text">Wie können in Reihe oder parallel geschaltete Widerstände zu einem "Gesamtwiderstand der Schaltung" zusammengefasst werden <i>(z.B. um daraus den Strom zu berechnen, den die Stromquelle liefern muss)</i>?</p>
</section>
</div>
<!-- Footer with Navigation -->
<div class="footer">
<div class="footer-left">
<p>Physik Klasse 8 – Widerstände in Reihen-und Parallelschaltungen</p>
</div>
<div class="footer-center">
<a class="nav-btn" href="1.html">← Zurück</a>
<a class="nav-btn" href="2.html">Nächste →</a>
</div>
<div class="footer-right">
<p>Seite 1</p>
</div>
</div>
</div>
<script>
(function(){
  // --- Circuit canvas (base drawing + red freehand overlay) ---
  const panel = document.getElementById('circuit-panel');
  const base = document.getElementById('circuit-base');
  const draw = document.getElementById('circuit-draw');
  const btnAdd = document.getElementById('add-parallel');
  const btnClear = document.getElementById('clear-drawing');
  const statusEl = document.getElementById('parallel-status');
  const explainEl = document.getElementById('circuit-explain');
  const explainBaseHTML = explainEl ? explainEl.innerHTML : '';

  if(!panel || !base || !draw) return;

  const bctx = base.getContext('2d', { willReadFrequently:false });
  const dctx = draw.getContext('2d', { willReadFrequently:false });

  // Buffer for preserving red drawing across resizes
  const buffer = document.createElement('canvas');
  const bufctx = buffer.getContext('2d', { willReadFrequently:false });

  const state = {
    dpr: 1,
    cssW: 0,
    cssH: 0,
    drawing: false,
    lastX: 0,
    lastY: 0,
    // 0 => only R1, 1 => +R2, 2 => +R3
    parallels: 0
  };

  const COLORS = {
    wire: '#111827',      // gray-900
    blue: '#2563EB',      // blue-600
    purple: '#8B5CF6',    // violet-500
    green: '#16A34A',     // green-600
    red: '#DC2626'        // red-600
  };

  function setStatus(){
    const shown = ['R1 (Herd)'];
    if(state.parallels >= 1) shown.push('R2 (Geschirrspüler)');
    if(state.parallels >= 2) shown.push('R3 (Kühlschrank)');
    if(statusEl){
      statusEl.textContent = 'Eingezeichnet: ' + shown.join(' + ');
    }
    if(btnAdd){
      if(state.parallels >= 2){
        btnAdd.disabled = true;
        btnAdd.style.opacity = '0.6';
        btnAdd.style.cursor = 'not-allowed';
        btnAdd.textContent = 'Alle Parallelverbraucher eingefügt';
      }
    }
    if(explainEl){
      const extra =
        state.parallels === 0 ? 'Noch ist nur R1 eingezeichnet.' :
        state.parallels === 1 ? 'Jetzt ist zusätzlich R2 parallel geschaltet.' :
        'Jetzt sind R2 und R3 parallel zu R1 geschaltet.';
      explainEl.innerHTML = explainBaseHTML + ' <span style="color:#374151;">(' + extra + ')</span>';
    }
  }

  // --- Geometry helpers (canvas pixels) ---
  function arrow(ctx, x1, y1, x2, y2, headLen){
    const dx = x2 - x1, dy = y2 - y1;
    const ang = Math.atan2(dy, dx);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - headLen * Math.cos(ang - Math.PI/6), y2 - headLen * Math.sin(ang - Math.PI/6));
    ctx.lineTo(x2 - headLen * Math.cos(ang + Math.PI/6), y2 - headLen * Math.sin(ang + Math.PI/6));
    ctx.closePath();
    ctx.fill();
  }

  function doubleArrow(ctx, x1, y1, x2, y2, headLen){
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    const dx = x2 - x1, dy = y2 - y1;
    const ang = Math.atan2(dy, dx);

    // head at x2
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - headLen * Math.cos(ang - Math.PI/6), y2 - headLen * Math.sin(ang - Math.PI/6));
    ctx.lineTo(x2 - headLen * Math.cos(ang + Math.PI/6), y2 - headLen * Math.sin(ang + Math.PI/6));
    ctx.closePath();
    ctx.fill();

    // head at x1
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x1 + headLen * Math.cos(ang - Math.PI/6), y1 + headLen * Math.sin(ang - Math.PI/6));
    ctx.lineTo(x1 + headLen * Math.cos(ang + Math.PI/6), y1 + headLen * Math.sin(ang + Math.PI/6));
    ctx.closePath();
    ctx.fill();
  }

  function node(ctx, x, y, r){
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();
  }

  function resistor(ctx, xL, xR, y, boxH, boxW, label, rNode){
    // shorter resistor rectangle; branch lines stop at node edge (not beyond)
    const mid = (xL + xR) / 2;
    const minLead = 22 * state.dpr;
    const maxBW = (xR - xL) - 2*rNode - 2*minLead;
    const bw = Math.max(36 * state.dpr, Math.min(boxW, maxBW));

    const bx1 = mid - bw/2;
    const bx2 = mid + bw/2;

    // lead in (from node edge to box)
    ctx.beginPath();
    ctx.moveTo(xL + rNode, y);
    ctx.lineTo(bx1, y);
    ctx.stroke();

    // box
    ctx.strokeRect(bx1, y - boxH/2, bw, boxH);

    // lead out (from box to node edge)
    ctx.beginPath();
    ctx.moveTo(bx2, y);
    ctx.lineTo(xR - rNode, y);
    ctx.stroke();

    // label
    ctx.save();
    ctx.fillStyle = COLORS.blue;
    ctx.font = `${Math.round(14 * state.dpr)}px Montserrat, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(label, mid, y - boxH/2 - 6*state.dpr);
    ctx.restore();
  }

  function drawCircuit(){
    const w = base.width;
    const h = base.height;

    // background
    bctx.save();
    bctx.setTransform(1,0,0,1,0,0);
    bctx.clearRect(0,0,w,h);
    bctx.fillStyle = '#FFFFFF';
    bctx.fillRect(0,0,w,h);
    bctx.restore();

    // common settings
    bctx.lineWidth = 2 * state.dpr;
    bctx.strokeStyle = COLORS.wire;
    bctx.fillStyle = COLORS.wire;

    // Rails a bit closer to the resistors (shorter branch leads), so the vertical "Zuleitung/Ableitung" appears longer
    const xL = w * 0.32;
    const xR = w * 0.68;

    const yTop = h * 0.38;
    const gap = h * 0.18;

    const ys = [yTop];
    if(state.parallels >= 1) ys.push(yTop + gap);
    if(state.parallels >= 2) ys.push(yTop + 2*gap);

    const yMin = ys[0];
    const yMax = ys[ys.length - 1];

    // Supply/return rails: longer above/below the branch area
    const extY = h * 0.20;
    const railTop = Math.max(0, yMin - extY);
    const railBot = Math.min(h, yMax + extY);

    bctx.beginPath();
    bctx.moveTo(xL, railTop);
    bctx.lineTo(xL, railBot);
    bctx.stroke();

    bctx.beginPath();
    bctx.moveTo(xR, railTop);
    bctx.lineTo(xR, railBot);
    bctx.stroke();

    // nodes and branches
    const rNode = 5 * state.dpr;
    const boxH = 28 * state.dpr;
    const boxW = w * 0.12; // noticeably shorter rectangles

    // R1
    resistor(bctx, xL, xR, ys[0], boxH, boxW, 'R1 (Herd)', rNode);
    node(bctx, xL, ys[0], rNode);
    node(bctx, xR, ys[0], rNode);

    if(state.parallels >= 1){
      resistor(bctx, xL, xR, ys[1], boxH, boxW, 'R2 (Geschirrspüler)', rNode);
      node(bctx, xL, ys[1], rNode);
      node(bctx, xR, ys[1], rNode);
    }
    if(state.parallels >= 2){
      resistor(bctx, xL, xR, ys[2], boxH, boxW, 'R3 (Kühlschrank)', rNode);
      node(bctx, xL, ys[2], rNode);
      node(bctx, xR, ys[2], rNode);
    }

    // Voltage U (purple) between terminals (above the top branch)
    const yU = Math.max(railTop + 14*state.dpr, ys[0] - h*0.20);
    bctx.save();
    bctx.strokeStyle = COLORS.purple;
    bctx.fillStyle = COLORS.purple;
    bctx.lineWidth = 2 * state.dpr;
    doubleArrow(bctx, xL + 10*state.dpr, yU, xR - 10*state.dpr, yU, 10*state.dpr);

    bctx.font = `${Math.round(16 * state.dpr)}px Montserrat, sans-serif`;
    bctx.textAlign = 'center';
    bctx.textBaseline = 'bottom';
    bctx.fillText('U', (xL + xR)/2, yU - 6*state.dpr);
    bctx.restore();

    // Current I (green) on the left rail (top -> down)
    bctx.save();
    bctx.strokeStyle = COLORS.green;
    bctx.fillStyle = COLORS.green;
    bctx.lineWidth = 3 * state.dpr;

    const yI1 = railTop + extY * 0.18;
    const yI2 = ys[0] - extY * 0.10;

    arrow(bctx, xL, yI1, xL, yI2, 10*state.dpr);

    bctx.font = `${Math.round(16 * state.dpr)}px Montserrat, sans-serif`;
    bctx.textAlign = 'left';
    bctx.textBaseline = 'middle';
    bctx.fillText('I', xL + 10*state.dpr, (yI1 + yI2)/2);
    bctx.restore();
  }

  // --- Red drawing overlay ---
  function getPos(e){
    const rect = draw.getBoundingClientRect();
    const xCss = (e.clientX - rect.left);
    const yCss = (e.clientY - rect.top);
    return { x: xCss * state.dpr, y: yCss * state.dpr };
  }

  function startDraw(e){
    state.drawing = true;
    const p = getPos(e);
    state.lastX = p.x;
    state.lastY = p.y;
    e.preventDefault();
  }

  function moveDraw(e){
    if(!state.drawing) return;
    const p = getPos(e);

    dctx.save();
    dctx.lineCap = 'round';
    dctx.lineJoin = 'round';
    dctx.strokeStyle = COLORS.red;
    dctx.lineWidth = 3 * state.dpr;
    dctx.beginPath();
    dctx.moveTo(state.lastX, state.lastY);
    dctx.lineTo(p.x, p.y);
    dctx.stroke();
    dctx.restore();

    state.lastX = p.x;
    state.lastY = p.y;
    e.preventDefault();
  }

  function endDraw(){
    state.drawing = false;
  }

  draw.addEventListener('pointerdown', startDraw);
  draw.addEventListener('pointermove', moveDraw);
  window.addEventListener('pointerup', endDraw);
  draw.addEventListener('pointerleave', endDraw);

  // --- Resizing ---
  function resize(){
    const rect = panel.getBoundingClientRect();
    const wCss = Math.max(1, rect.width);
    let hCss = Math.max(1, rect.height);

    // In rare cases (initial layout), height can be 0 — fall back to 4:3
    if(hCss < 10) hCss = Math.max(260, wCss * 0.75);

    const dpr = window.devicePixelRatio || 1;

    // save red overlay
    if(draw.width && draw.height){
      buffer.width = draw.width;
      buffer.height = draw.height;
      bufctx.clearRect(0,0,buffer.width, buffer.height);
      bufctx.drawImage(draw, 0, 0);
    }

    state.cssW = wCss;
    state.cssH = hCss;
    state.dpr = dpr;

    base.width  = Math.round(wCss * dpr);
    base.height = Math.round(hCss * dpr);
    draw.width  = Math.round(wCss * dpr);
    draw.height = Math.round(hCss * dpr);

    drawCircuit();

    // restore red overlay
    dctx.clearRect(0,0,draw.width,draw.height);
    if(buffer.width && buffer.height){
      dctx.drawImage(buffer, 0, 0, buffer.width, buffer.height, 0, 0, draw.width, draw.height);
    }
  }

  const ro = new ResizeObserver(() => resize());
  ro.observe(panel);
  window.addEventListener('resize', () => resize());

  // --- Buttons ---
  if(btnAdd){
    btnAdd.addEventListener('click', () => {
      if(state.parallels < 2){
        state.parallels += 1;
        drawCircuit();
        setStatus();
      }
    });
  }

  if(btnClear){
    btnClear.addEventListener('click', () => {
      dctx.clearRect(0,0,draw.width,draw.height);
    });
  }

  // initial paint (after layout)
  setStatus();
  requestAnimationFrame(() => resize());
})();
</script>
</body>
</html>
